#!/usr/bin/env python3
"""
Plot batch latencies from batching_trace_summary.csv.

This script expects the CSV generated by batching tracing (when trace_enabled is
true). It produces three scatter plots:

1. Combined batches (CPU + GPU)
2. CPU-only batches
3. GPU-only batches

Usage:
  ./scripts/plot_batch_summary.py PATH_TO/batching_trace_summary.csv
  ./scripts/plot_batch_summary.py PATH_TO/file.csv --output plots.png
"""

from __future__ import annotations

import argparse
import csv
import sys
from pathlib import Path
from typing import Iterable, List, Tuple

import matplotlib.pyplot as plt


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Plot batch latencies from batching_trace_summary.csv."
    )
    parser.add_argument(
        "summary_csv",
        type=Path,
        help="Path to batching_trace_summary.csv",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        help=(
            "Optional output image path (PNG/JPG/etc.). "
            "If omitted the plots are shown interactively."
        ),
    )
    return parser.parse_args()


def load_latencies(
    csv_path: Path,
) -> List[Tuple[int, float, str]]:
    batches: List[Tuple[int, float, str]] = []
    with csv_path.open(newline="") as handle:
        reader = csv.DictReader(handle)
        required = {"batch_id", "total_ms", "worker_type"}
        missing = sorted(required - set(reader.fieldnames or []))
        if missing:
            raise ValueError(
                f"{csv_path} is missing required columns: {', '.join(missing)}"
            )
        for row in reader:
            try:
                batch_id = int(row["batch_id"])
                latency = float(row["total_ms"])
            except ValueError as exc:
                raise ValueError(f"Invalid numeric values in row: {row}") from exc
            worker_type = (row.get("worker_type") or "unknown").strip().lower()
            batches.append((batch_id, latency, worker_type))
    return batches


def filter_latencies(
    data: Iterable[Tuple[int, float, str]],
    *,
    worker_type: str | None = None,
) -> Tuple[List[int], List[float]]:
    ids: List[int] = []
    latencies: List[float] = []
    for batch_id, latency, device in data:
        if worker_type is None or device == worker_type:
            ids.append(batch_id)
            latencies.append(latency)
    return ids, latencies


def scatter_plot(ax, x: List[int], y: List[float], title: str) -> None:
    if not x:
        ax.set_title(f"{title} (no data)")
        ax.set_xlabel("Batch ID")
        ax.set_ylabel("Latency (ms)")
        ax.grid(True, linestyle="--", alpha=0.4)
        return
    ax.scatter(x, y, s=14, alpha=0.7)
    ax.set_title(title)
    ax.set_xlabel("Batch ID")
    ax.set_ylabel("Latency (ms)")
    ax.grid(True, linestyle="--", alpha=0.4)


def main() -> int:
    args = parse_args()
    csv_path = args.summary_csv
    if not csv_path.exists():
        print(f"error: CSV not found: {csv_path}", file=sys.stderr)
        return 1

    try:
        data = load_latencies(csv_path)
    except ValueError as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 1

    all_ids, all_lat = filter_latencies(data)
    cpu_ids, cpu_lat = filter_latencies(data, worker_type="cpu")
    gpu_ids, gpu_lat = filter_latencies(data, worker_type="cuda")

    fig, axes = plt.subplots(3, 1, figsize=(10, 12), sharex=True)
    scatter_plot(axes[0], all_ids, all_lat, "All workers (CPU + GPU)")
    scatter_plot(axes[1], cpu_ids, cpu_lat, "CPU workers only")
    scatter_plot(axes[2], gpu_ids, gpu_lat, "GPU workers only")
    fig.tight_layout()

    if args.output:
        output_path = args.output
        output_path.parent.mkdir(parents=True, exist_ok=True)
        fig.savefig(output_path, dpi=150)
        print(f"Saved plots to {output_path}")
    else:
        plt.show()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
