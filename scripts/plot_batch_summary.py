#!/usr/bin/env python3
"""
Plot batch latencies from batching_trace_summary.csv.

This script expects the CSV generated by batching tracing (when trace_enabled is
true). It produces three scatter plots:

1. Combined batches (CPU + GPU)
2. CPU-only batches
3. GPU-only batches

Usage:
  ./scripts/plot_batch_summary.py PATH_TO/batching_trace_summary.csv
  ./scripts/plot_batch_summary.py PATH_TO/file.csv --output plots.png
"""

from __future__ import annotations

import argparse
import csv
import sys
from collections import deque
from pathlib import Path
from typing import Iterable, List, Sequence, Tuple

import matplotlib.pyplot as plt


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Plot batch latencies from batching_trace_summary.csv."
    )
    parser.add_argument(
        "summary_csv",
        type=Path,
        help="Path to batching_trace_summary.csv",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        help=(
            "Optional output image path (PNG/JPG/etc.). "
            "If omitted the plots are shown interactively."
        ),
    )
    return parser.parse_args()


def load_latencies(
    csv_path: Path,
) -> List[Tuple[int, float, str, int, Tuple[float, ...]]]:
    batches: List[Tuple[int, float, str, int, Tuple[float, ...]]] = []
    with csv_path.open(newline="") as handle:
        reader = csv.DictReader(handle)
        required = {
            "batch_id",
            "total_ms",
            "worker_type",
            "batch_size",
            "queue_ms",
            "batch_ms",
            "submit_ms",
            "scheduling_ms",
            "codelet_ms",
            "inference_ms",
            "callback_ms",
        }
        missing = sorted(required - set(reader.fieldnames or []))
        if missing:
            raise ValueError(
                f"{csv_path} is missing required columns: {', '.join(missing)}"
            )
        for row in reader:
            try:
                batch_id = int(row["batch_id"])
                latency = float(row["total_ms"])
            except ValueError as exc:
                raise ValueError(f"Invalid numeric values in row: {row}") from exc
            worker_type = (row.get("worker_type") or "unknown").strip().lower()
            batch_size = int(row["batch_size"])
            breakdown = (
                float(row["queue_ms"]),
                float(row["batch_ms"]),
                float(row["submit_ms"]),
                float(row["scheduling_ms"]),
                float(row["codelet_ms"]),
                float(row["inference_ms"]),
                float(row["callback_ms"]),
            )
            batches.append((batch_id, latency, worker_type, batch_size, breakdown))
    return batches


def filter_latencies(
    data: Iterable[Tuple[int, float, str, int, Tuple[float, ...]]],
    *,
    worker_type: str | None = None,
) -> Tuple[List[int], List[float], List[int], List[Tuple[float, ...]]]:
    ids: List[int] = []
    latencies: List[float] = []
    batch_sizes: List[int] = []
    breakdowns: List[Tuple[float, ...]] = []
    for batch_id, latency, device, batch_size, breakdown in data:
        if worker_type is None or device == worker_type:
            ids.append(batch_id)
            latencies.append(latency)
            batch_sizes.append(batch_size)
            breakdowns.append(breakdown)
    return ids, latencies, batch_sizes, breakdowns


def plot_latency_stack(
    ax,
    batch_ids: Sequence[int],
    breakdowns: Sequence[Tuple[float, ...]],
) -> None:
    if not batch_ids or not breakdowns:
        ax.set_title("Latency composition per batch (no data)")
        ax.set_xlabel("Batch ID")
        ax.set_ylabel("Latency contribution (ms)")
        ax.grid(True, linestyle="--", alpha=0.3)
        return

    labels = [
        "queue",
        "batch",
        "submit",
        "scheduling",
        "codelet",
        "inference",
        "callback",
    ]
    components = list(map(list, zip(*breakdowns)))
    bottom = [0.0] * len(batch_ids)
    ax.set_title("Latency composition per batch")
    for values, label in zip(components, labels):
        ax.bar(batch_ids, values, bottom=bottom, label=label, width=0.6)
        bottom = [b + v for b, v in zip(bottom, values)]
    ax.set_xlabel("Batch ID")
    ax.set_ylabel("Latency contribution (ms)")
    ax.legend(loc="upper right", fontsize="small")
    ax.grid(True, linestyle="--", alpha=0.3)


def scatter_plot(
    ax, x: List[int], y: List[float], title: str, *, color: str | None = None
) -> None:
    if not x:
        ax.set_title(f"{title} (no data)")
        ax.set_xlabel("Batch ID")
        ax.set_ylabel("Latency (ms)")
        ax.grid(True, linestyle="--", alpha=0.4)
        return
    ax.scatter(x, y, s=14, alpha=0.7, c=color)
    ax.set_title(title)
    ax.set_xlabel("Batch ID")
    ax.set_ylabel("Latency (ms)")
    ax.grid(True, linestyle="--", alpha=0.4)


def plot_violin(
    ax,
    data: Sequence[float],
    label: str,
    color: str | None = None,
) -> None:
    if not data:
        ax.set_title(f"{label} (no data)")
        ax.grid(True, linestyle="--", alpha=0.4)
        return
    parts = ax.violinplot(data, showmeans=True, showmedians=False)
    if color:
        for pc in parts["bodies"]:
            pc.set_facecolor(color)
            pc.set_edgecolor("black")
        parts["cbars"].set_edgecolor(color)
        parts["cmins"].set_edgecolor(color)
        parts["cmaxes"].set_edgecolor(color)
    ax.set_title(label)
    ax.grid(True, linestyle="--", alpha=0.4)


def scatter_with_size(
    ax,
    x: Sequence[int],
    y: Sequence[float],
    sizes: Sequence[int],
    title: str,
) -> None:
    if not x or not y or not sizes:
        ax.set_title(f"{title} (no data)")
        ax.set_xlabel("Batch ID")
        ax.set_ylabel("Latency (ms)")
        ax.grid(True, linestyle="--", alpha=0.4)
        return
    max_size = max(sizes)
    min_size = max(1, min(sizes))
    scale = []
    for value in sizes:
        norm = value / max_size if max_size > 0 else 0.0
        scale.append(50 + norm * 200)
    scatter = ax.scatter(
        x,
        y,
        s=scale,
        c=sizes,
        cmap="viridis",
        alpha=0.7,
    )
    ax.set_title(title)
    ax.set_xlabel("Batch ID")
    ax.set_ylabel("Latency (ms)")
    ax.grid(True, linestyle="--", alpha=0.4)
    cbar = plt.colorbar(scatter, ax=ax)
    cbar.set_label("Batch size")


def compute_moving_average(
    ids: Sequence[int], values: Sequence[float], window: int = 50
) -> Tuple[List[int], List[float]]:
    if not ids or not values:
        return [], []
    sorted_pairs = sorted(zip(ids, values), key=lambda pair: pair[0])
    sorted_ids = [pair[0] for pair in sorted_pairs]
    sorted_vals = [pair[1] for pair in sorted_pairs]
    window = max(1, min(window, len(sorted_vals)))
    rolling_ids: List[int] = []
    rolling_vals: List[float] = []
    window_sum = 0.0
    current = deque()
    for batch_id, value in zip(sorted_ids, sorted_vals):
        current.append(value)
        window_sum += value
        if len(current) > window:
            window_sum -= current.popleft()
        rolling_ids.append(batch_id)
        rolling_vals.append(window_sum / len(current))
    return rolling_ids, rolling_vals


def main() -> int:
    args = parse_args()
    csv_path = args.summary_csv
    if not csv_path.exists():
        print(f"error: CSV not found: {csv_path}", file=sys.stderr)
        return 1

    try:
        data = load_latencies(csv_path)
    except ValueError as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 1

    all_ids, all_lat, all_sizes, all_breakdowns = filter_latencies(data)
    cpu_ids, cpu_lat, cpu_sizes, cpu_breakdowns = filter_latencies(
        data, worker_type="cpu"
    )
    gpu_ids, gpu_lat, gpu_sizes, gpu_breakdowns = filter_latencies(
        data, worker_type="cuda"
    )
    cpu_color = "#d62728"

    fig, axes = plt.subplots(8, 1, figsize=(12, 28), sharex=False)
    scatter_plot(axes[0], all_ids, all_lat, "All workers (CPU + GPU)")
    if cpu_ids:
        axes[0].scatter(cpu_ids, cpu_lat, s=14, alpha=0.7, c=cpu_color)
    scatter_with_size(
        axes[1], all_ids, all_lat, all_sizes, "Latency vs batch size (multidim)"
    )
    scatter_plot(axes[2], cpu_ids, cpu_lat, "CPU workers only", color=cpu_color)
    scatter_plot(axes[3], gpu_ids, gpu_lat, "GPU workers only")
    avg_ids, avg_vals = compute_moving_average(all_ids, all_lat)
    if avg_ids:
        axes[4].plot(avg_ids, avg_vals, color="purple")
        axes[4].set_title("Rolling average latency (window=50)")
        axes[4].set_xlabel("Batch ID")
        axes[4].set_ylabel("Latency (ms)")
        axes[4].grid(True, linestyle="--", alpha=0.3)
    else:
        axes[4].set_title("Rolling average latency (no data)")
        axes[4].grid(True, linestyle="--", alpha=0.3)

    plot_latency_stack(axes[5], all_ids, all_breakdowns)

    axes[6].hist(all_sizes, bins=30, alpha=0.7, label="All", color="gray")
    if cpu_sizes:
        axes[6].hist(cpu_sizes, bins=30, alpha=0.5, label="CPU", color=cpu_color)
    if gpu_sizes:
        axes[6].hist(gpu_sizes, bins=30, alpha=0.5, label="GPU", color="blue")
    axes[6].set_title("Batch size distribution")
    axes[6].set_xlabel("Batch size")
    axes[6].set_ylabel("Count")
    axes[6].legend()
    axes[6].grid(True, linestyle="--", alpha=0.3)

    violin_data = []
    labels = []
    if cpu_lat:
        violin_data.append(cpu_lat)
        labels.append("CPU")
    if gpu_lat:
        violin_data.append(gpu_lat)
        labels.append("GPU")
    if violin_data:
        axes[7].violinplot(violin_data, showmeans=True, showmedians=False)
        axes[7].set_xticks(range(1, len(labels) + 1), labels)
        axes[7].set_title("Latency distribution (violin plot)")
        axes[7].set_ylabel("Latency (ms)")
        axes[7].grid(True, linestyle="--", alpha=0.3)
    else:
        axes[7].set_title("Latency distribution (no data)")
        axes[7].grid(True, linestyle="--", alpha=0.3)
    fig.tight_layout()

    if args.output:
        output_path = args.output
        output_path.parent.mkdir(parents=True, exist_ok=True)
        fig.savefig(output_path, dpi=150)
        print(f"Saved plots to {output_path}")
    else:
        plt.show()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
