#!/usr/bin/env python3
"""
Plot batch latencies from batching_trace_summary.csv.

This script expects the CSV generated by batching tracing (when trace_enabled is
true). It produces three scatter plots:

1. Combined batches (CPU + GPU)
2. CPU-only batches
3. GPU-only batches

Usage:
  ./scripts/plot_batch_summary.py PATH_TO/batching_trace_summary.csv
  ./scripts/plot_batch_summary.py PATH_TO/file.csv --output plots.png
"""

from __future__ import annotations

import argparse
import csv
import sys
from pathlib import Path
from typing import Iterable, List, Sequence, Tuple

import matplotlib.pyplot as plt


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Plot batch latencies from batching_trace_summary.csv."
    )
    parser.add_argument(
        "summary_csv",
        type=Path,
        help="Path to batching_trace_summary.csv",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        help=(
            "Optional output image path (PNG/JPG/etc.). "
            "If omitted the plots are shown interactively."
        ),
    )
    return parser.parse_args()


def load_latencies(
    csv_path: Path,
) -> List[Tuple[int, float, str, Tuple[float, ...]]]:
    batches: List[Tuple[int, float, str, Tuple[float, ...]]] = []
    with csv_path.open(newline="") as handle:
        reader = csv.DictReader(handle)
        required = {
            "batch_id",
            "total_ms",
            "worker_type",
            "queue_ms",
            "batch_ms",
            "submit_ms",
            "scheduling_ms",
            "codelet_ms",
            "inference_ms",
            "callback_ms",
        }
        missing = sorted(required - set(reader.fieldnames or []))
        if missing:
            raise ValueError(
                f"{csv_path} is missing required columns: {', '.join(missing)}"
            )
        for row in reader:
            try:
                batch_id = int(row["batch_id"])
                latency = float(row["total_ms"])
            except ValueError as exc:
                raise ValueError(f"Invalid numeric values in row: {row}") from exc
            worker_type = (row.get("worker_type") or "unknown").strip().lower()
            breakdown = (
                float(row["queue_ms"]),
                float(row["batch_ms"]),
                float(row["submit_ms"]),
                float(row["scheduling_ms"]),
                float(row["codelet_ms"]),
                float(row["inference_ms"]),
                float(row["callback_ms"]),
            )
            batches.append((batch_id, latency, worker_type, breakdown))
    return batches


def filter_latencies(
    data: Iterable[Tuple[int, float, str]],
    *,
    worker_type: str | None = None,
) -> Tuple[List[int], List[float], List[Tuple[float, ...]]]:
    ids: List[int] = []
    latencies: List[float] = []
    breakdowns: List[Tuple[float, ...]] = []
    for batch_id, latency, device, breakdown in data:
        if worker_type is None or device == worker_type:
            ids.append(batch_id)
            latencies.append(latency)
            breakdowns.append(breakdown)
    return ids, latencies, breakdowns


def plot_latency_stack(
    ax,
    batch_ids: Sequence[int],
    breakdowns: Sequence[Tuple[float, ...]],
) -> None:
    if not batch_ids or not breakdowns:
        ax.set_title("Latency composition per batch (no data)")
        ax.set_xlabel("Batch ID")
        ax.set_ylabel("Latency contribution (ms)")
        ax.grid(True, linestyle="--", alpha=0.3)
        return

    labels = [
        "queue",
        "batch",
        "submit",
        "scheduling",
        "codelet",
        "inference",
        "callback",
    ]
    components = list(map(list, zip(*breakdowns)))
    bottom = [0.0] * len(batch_ids)
    ax.set_title("Latency composition per batch")
    for values, label in zip(components, labels):
        ax.bar(batch_ids, values, bottom=bottom, label=label, width=0.6)
        bottom = [b + v for b, v in zip(bottom, values)]
    ax.set_xlabel("Batch ID")
    ax.set_ylabel("Latency contribution (ms)")
    ax.legend(loc="upper right", fontsize="small")
    ax.grid(True, linestyle="--", alpha=0.3)


def scatter_plot(
    ax, x: List[int], y: List[float], title: str, *, color: str | None = None
) -> None:
    if not x:
        ax.set_title(f"{title} (no data)")
        ax.set_xlabel("Batch ID")
        ax.set_ylabel("Latency (ms)")
        ax.grid(True, linestyle="--", alpha=0.4)
        return
    ax.scatter(x, y, s=14, alpha=0.7, c=color)
    ax.set_title(title)
    ax.set_xlabel("Batch ID")
    ax.set_ylabel("Latency (ms)")
    ax.grid(True, linestyle="--", alpha=0.4)


def main() -> int:
    args = parse_args()
    csv_path = args.summary_csv
    if not csv_path.exists():
        print(f"error: CSV not found: {csv_path}", file=sys.stderr)
        return 1

    try:
        data = load_latencies(csv_path)
    except ValueError as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 1

    all_ids, all_lat, all_breakdowns = filter_latencies(data)
    cpu_ids, cpu_lat, cpu_breakdowns = filter_latencies(data, worker_type="cpu")
    gpu_ids, gpu_lat, gpu_breakdowns = filter_latencies(data, worker_type="cuda")
    cpu_color = "#d62728"

    fig, axes = plt.subplots(4, 1, figsize=(12, 14), sharex=True)
    scatter_plot(axes[0], all_ids, all_lat, "All workers (CPU + GPU)")
    if cpu_ids:
        axes[0].scatter(cpu_ids, cpu_lat, s=14, alpha=0.7, c=cpu_color)
    scatter_plot(axes[1], cpu_ids, cpu_lat, "CPU workers only", color=cpu_color)
    scatter_plot(axes[2], gpu_ids, gpu_lat, "GPU workers only")
    plot_latency_stack(axes[3], all_ids, all_breakdowns)
    fig.tight_layout()

    if args.output:
        output_path = args.output
        output_path.parent.mkdir(parents=True, exist_ok=True)
        fig.savefig(output_path, dpi=150)
        print(f"Saved plots to {output_path}")
    else:
        plt.show()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
