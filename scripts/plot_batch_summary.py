#!/usr/bin/env python3
"""
Plot batch latencies from batching_trace_summary.csv.

This script expects the CSV generated by batching tracing (when trace_enabled is
true). It produces three scatter plots:

1. Combined batches (CPU + GPU)
2. CPU-only batches
3. GPU-only batches

Usage:
  ./scripts/plot_batch_summary.py PATH_TO/batching_trace_summary.csv
  ./scripts/plot_batch_summary.py PATH_TO/file.csv --output plots.png
"""

from __future__ import annotations

import argparse
import csv
import sys
from collections import Counter, deque
from pathlib import Path
from typing import Iterable, List, Sequence, Tuple

import matplotlib.pyplot as plt
import numpy as np

PHASE_LABELS = [
    "queue",
    "batch",
    "submit",
    "scheduling",
    "codelet",
    "inference",
    "callback",
]


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Plot batch latencies from batching_trace_summary.csv."
    )
    parser.add_argument(
        "summary_csv",
        type=Path,
        help="Path to batching_trace_summary.csv",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        help=(
            "Optional output image path (PNG/JPG/etc.). "
            "If omitted the plots are shown interactively."
        ),
    )
    return parser.parse_args()


def load_latencies(
    csv_path: Path,
) -> List[Tuple[int, float, str, int, int, Tuple[float, ...]]]:
    batches: List[Tuple[int, float, str, int, int, Tuple[float, ...]]] = []
    with csv_path.open(newline="") as handle:
        reader = csv.DictReader(handle)
        required = {
            "batch_id",
            "total_ms",
            "worker_type",
            "worker_id",
            "batch_size",
        }
        required.update(f"{label}_ms" for label in PHASE_LABELS)
        missing = sorted(required - set(reader.fieldnames or []))
        if missing:
            raise ValueError(
                f"{csv_path} is missing required columns: {', '.join(missing)}"
            )
        for row in reader:
            try:
                batch_id = int(row["batch_id"])
                latency = float(row["total_ms"])
            except ValueError as exc:
                raise ValueError(f"Invalid numeric values in row: {row}") from exc
            worker_type = (row.get("worker_type") or "unknown").strip().lower()
            worker_id = int(row["worker_id"])
            batch_size = int(row["batch_size"])
            breakdown = tuple(float(row[f"{label}_ms"]) for label in PHASE_LABELS)
            batches.append(
                (batch_id, latency, worker_type, worker_id, batch_size, breakdown)
            )
    return batches


def filter_latencies(
    data: Iterable[Tuple[int, float, str, int, int, Tuple[float, ...]]],
    *,
    worker_type: str | None = None,
) -> Tuple[List[int], List[float], List[int], List[int], List[Tuple[float, ...]]]:
    ids: List[int] = []
    latencies: List[float] = []
    worker_ids: List[int] = []
    batch_sizes: List[int] = []
    breakdowns: List[Tuple[float, ...]] = []
    for batch_id, latency, device, worker_id, batch_size, breakdown in data:
        if worker_type is None or device == worker_type:
            ids.append(batch_id)
            latencies.append(latency)
            worker_ids.append(worker_id)
            batch_sizes.append(batch_size)
            breakdowns.append(breakdown)
    return ids, latencies, worker_ids, batch_sizes, breakdowns


def plot_latency_stack(
    ax,
    batch_ids: Sequence[int],
    breakdowns: Sequence[Tuple[float, ...]],
) -> None:
    if not batch_ids or not breakdowns:
        ax.set_title("Latency composition per batch (no data)")
        ax.set_xlabel("Batch ID")
        ax.set_ylabel("Latency contribution (ms)")
        ax.grid(True, linestyle="--", alpha=0.3)
        return

    labels = PHASE_LABELS
    components = list(map(list, zip(*breakdowns)))
    bottom = [0.0] * len(batch_ids)
    ax.set_title("Latency composition per batch")
    for values, label in zip(components, labels):
        ax.bar(batch_ids, values, bottom=bottom, label=label, width=0.6)
        bottom = [b + v for b, v in zip(bottom, values)]
    ax.set_xlabel("Batch ID")
    ax.set_ylabel("Latency contribution (ms)")
    ax.legend(loc="upper right", fontsize="small")
    ax.grid(True, linestyle="--", alpha=0.3)


def scatter_plot(
    ax, x: List[int], y: List[float], title: str, *, color: str | None = None
) -> None:
    if not x:
        ax.set_title(f"{title} (no data)")
        ax.set_xlabel("Batch ID")
        ax.set_ylabel("Latency (ms)")
        ax.grid(True, linestyle="--", alpha=0.4)
        return
    ax.scatter(x, y, s=14, alpha=0.7, c=color)
    ax.set_title(title)
    ax.set_xlabel("Batch ID")
    ax.set_ylabel("Latency (ms)")
    ax.grid(True, linestyle="--", alpha=0.4)


def plot_violin(
    ax,
    data: Sequence[float],
    label: str,
    color: str | None = None,
) -> None:
    if not data:
        ax.set_title(f"{label} (no data)")
        ax.grid(True, linestyle="--", alpha=0.4)
        return
    parts = ax.violinplot(data, showmeans=True, showmedians=False)
    if color:
        for pc in parts["bodies"]:
            pc.set_facecolor(color)
            pc.set_edgecolor("black")
        parts["cbars"].set_edgecolor(color)
        parts["cmins"].set_edgecolor(color)
        parts["cmaxes"].set_edgecolor(color)
    ax.set_title(label)
    ax.grid(True, linestyle="--", alpha=0.4)


def scatter_with_size(
    ax,
    x: Sequence[int],
    y: Sequence[float],
    sizes: Sequence[int],
    title: str,
) -> None:
    if not x or not y or not sizes:
        ax.set_title(f"{title} (no data)")
        ax.set_xlabel("Batch ID")
        ax.set_ylabel("Latency (ms)")
        ax.grid(True, linestyle="--", alpha=0.4)
        return
    max_size = max(sizes)
    min_size = max(1, min(sizes))
    scale = []
    for value in sizes:
        norm = value / max_size if max_size > 0 else 0.0
        scale.append(50 + norm * 200)
    scatter = ax.scatter(
        x,
        y,
        s=scale,
        c=sizes,
        cmap="viridis",
        alpha=0.7,
    )
    ax.set_title(title)
    ax.set_xlabel("Batch ID")
    ax.set_ylabel("Latency (ms)")
    ax.grid(True, linestyle="--", alpha=0.4)
    cbar = plt.colorbar(scatter, ax=ax)
    cbar.set_label("Batch size")


def plot_worker_boxplots(
    ax,
    worker_ids: Sequence[int],
    latencies: Sequence[float],
) -> None:
    data = {}
    for worker, latency in zip(worker_ids, latencies):
        if worker < 0:
            continue
        data.setdefault(worker, []).append(latency)
    if not data:
        ax.set_title("Worker latency boxplots (no data)")
        ax.set_xlabel("Worker ID")
        ax.set_ylabel("Latency (ms)")
        ax.grid(True, linestyle="--", alpha=0.4)
        return
    sorted_items = sorted(data.items(), key=lambda item: item[0])
    ax.boxplot(
        [item[1] for item in sorted_items],
        labels=[item[0] for item in sorted_items],
        showmeans=True,
    )
    ax.set_title("Worker latency boxplots")
    ax.set_xlabel("Worker ID")
    ax.set_ylabel("Latency (ms)")
    ax.grid(True, linestyle="--", alpha=0.4)


def plot_phase_heatmap(
    ax,
    batch_sizes: Sequence[int],
    breakdowns: Sequence[Tuple[float, ...]],
    max_columns: int = 12,
) -> None:
    if not batch_sizes or not breakdowns:
        ax.set_title("Phase heatmap (no data)")
        ax.set_xlabel("Batch size")
        ax.set_ylabel("Phase")
        ax.grid(True, linestyle="--", alpha=0.4)
        return

    counter = Counter(batch_sizes)
    top_sizes = [size for size, _ in counter.most_common(max_columns)]
    top_sizes.sort()
    if not top_sizes:
        ax.set_title("Phase heatmap (no data)")
        ax.set_xlabel("Batch size")
        ax.set_ylabel("Phase")
        ax.grid(True, linestyle="--", alpha=0.4)
        return

    index = {size: idx for idx, size in enumerate(top_sizes)}
    totals = np.zeros((len(PHASE_LABELS), len(top_sizes)), dtype=float)
    counts = np.zeros_like(totals)

    for size, phases in zip(batch_sizes, breakdowns):
        col = index.get(size)
        if col is None:
            continue
        for row, value in enumerate(phases):
            totals[row, col] += value
            counts[row, col] += 1

    with np.errstate(invalid="ignore"):
        averages = np.divide(totals, counts, where=counts > 0)

    masked = np.ma.masked_invalid(averages)
    im = ax.imshow(masked, aspect="auto", cmap="magma", origin="lower")
    ax.set_xticks(range(len(top_sizes)), [str(size) for size in top_sizes])
    ax.set_yticks(range(len(PHASE_LABELS)), PHASE_LABELS)
    ax.set_xlabel("Batch size")
    ax.set_ylabel("Phase")
    ax.set_title("Phase heatmap (avg ms)")
    plt.colorbar(im, ax=ax, label="Average duration (ms)")


def plot_phase_pareto(
    ax,
    breakdowns: Sequence[Tuple[float, ...]],
) -> None:
    if not breakdowns:
        ax.set_title("Phase Pareto (no data)")
        ax.set_xlabel("Phase")
        ax.set_ylabel("Average duration (ms)")
        ax.grid(True, axis="y", linestyle="--", alpha=0.3)
        return
    totals = np.zeros(len(PHASE_LABELS), dtype=float)
    for phases in breakdowns:
        totals += np.array(phases)
    averages = totals / len(breakdowns)
    sorted_indices = np.argsort(-averages)
    sorted_labels = [PHASE_LABELS[idx] for idx in sorted_indices]
    sorted_values = averages[sorted_indices]
    ax.bar(sorted_labels, sorted_values, color="#6a4c93")
    ax.set_title("Phase Pareto (avg ms)")
    ax.set_xlabel("Phase")
    ax.set_ylabel("Average duration (ms)")
    ax.grid(True, axis="y", linestyle="--", alpha=0.3)


def compute_moving_average(
    ids: Sequence[int], values: Sequence[float], window: int = 50
) -> Tuple[List[int], List[float]]:
    if not ids or not values:
        return [], []
    sorted_pairs = sorted(zip(ids, values), key=lambda pair: pair[0])
    sorted_ids = [pair[0] for pair in sorted_pairs]
    sorted_vals = [pair[1] for pair in sorted_pairs]
    window = max(1, min(window, len(sorted_vals)))
    rolling_ids: List[int] = []
    rolling_vals: List[float] = []
    window_sum = 0.0
    current = deque()
    for batch_id, value in zip(sorted_ids, sorted_vals):
        current.append(value)
        window_sum += value
        if len(current) > window:
            window_sum -= current.popleft()
        rolling_ids.append(batch_id)
        rolling_vals.append(window_sum / len(current))
    return rolling_ids, rolling_vals


def compute_cumulative_latency(
    ids: Sequence[int], values: Sequence[float]
) -> Tuple[List[int], List[float]]:
    if not ids or not values:
        return [], []
    sorted_pairs = sorted(zip(ids, values), key=lambda pair: pair[0])
    cum_sum = 0.0
    cum_ids: List[int] = []
    cum_vals: List[float] = []
    for batch_id, latency in sorted_pairs:
        cum_sum += latency
        cum_ids.append(batch_id)
        cum_vals.append(cum_sum)
    return cum_ids, cum_vals


def main() -> int:
    args = parse_args()
    csv_path = args.summary_csv
    if not csv_path.exists():
        print(f"error: CSV not found: {csv_path}", file=sys.stderr)
        return 1

    try:
        data = load_latencies(csv_path)
    except ValueError as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 1

    all_ids, all_lat, all_workers, all_sizes, all_breakdowns = filter_latencies(data)
    cpu_ids, cpu_lat, cpu_workers, cpu_sizes, cpu_breakdowns = filter_latencies(
        data, worker_type="cpu"
    )
    gpu_ids, gpu_lat, gpu_workers, gpu_sizes, gpu_breakdowns = filter_latencies(
        data, worker_type="cuda"
    )
    cpu_color = "#d62728"

    fig, axes = plt.subplots(12, 1, figsize=(12, 44), sharex=False)
    scatter_plot(axes[0], all_ids, all_lat, "All workers (CPU + GPU)")
    if cpu_ids:
        axes[0].scatter(cpu_ids, cpu_lat, s=14, alpha=0.7, c=cpu_color)
    scatter_with_size(
        axes[1], all_ids, all_lat, all_sizes, "Latency vs batch size (multidim)"
    )
    scatter_plot(axes[2], cpu_ids, cpu_lat, "CPU workers only", color=cpu_color)
    scatter_plot(axes[3], gpu_ids, gpu_lat, "GPU workers only")
    cum_ids, cum_vals = compute_cumulative_latency(all_ids, all_lat)
    if cum_ids:
        axes[4].plot(cum_ids, cum_vals, color="teal")
        axes[4].set_title("Cumulative latency vs batch ID")
        axes[4].set_xlabel("Batch ID")
        axes[4].set_ylabel("Cumulative latency (ms)")
        axes[4].grid(True, linestyle="--", alpha=0.3)
    else:
        axes[4].set_title("Cumulative latency vs batch ID (no data)")
        axes[4].grid(True, linestyle="--", alpha=0.3)

    avg_ids, avg_vals = compute_moving_average(all_ids, all_lat)
    if avg_ids:
        axes[5].plot(avg_ids, avg_vals, color="purple")
        axes[5].set_title("Rolling average latency (window=50)")
        axes[5].set_xlabel("Batch ID")
        axes[5].set_ylabel("Latency (ms)")
        axes[5].grid(True, linestyle="--", alpha=0.3)
    else:
        axes[5].set_title("Rolling average latency (no data)")
        axes[5].grid(True, linestyle="--", alpha=0.3)

    plot_latency_stack(axes[6], all_ids, all_breakdowns)
    plot_phase_heatmap(axes[7], all_sizes, all_breakdowns)
    plot_phase_pareto(axes[8], all_breakdowns)

    axes[9].hist(all_sizes, bins=30, alpha=0.7, label="All", color="gray")
    if cpu_sizes:
        axes[9].hist(cpu_sizes, bins=30, alpha=0.5, label="CPU", color=cpu_color)
    if gpu_sizes:
        axes[9].hist(gpu_sizes, bins=30, alpha=0.5, label="GPU", color="blue")
    axes[9].set_title("Batch size distribution")
    axes[9].set_xlabel("Batch size")
    axes[9].set_ylabel("Count")
    axes[9].legend()
    axes[9].grid(True, linestyle="--", alpha=0.3)

    violin_data = []
    labels = []
    if cpu_lat:
        violin_data.append(cpu_lat)
        labels.append("CPU")
    if gpu_lat:
        violin_data.append(gpu_lat)
        labels.append("GPU")
    if violin_data:
        axes[10].violinplot(violin_data, showmeans=True, showmedians=False)
        axes[10].set_xticks(range(1, len(labels) + 1), labels)
        axes[10].set_title("Latency distribution (violin plot)")
        axes[10].set_ylabel("Latency (ms)")
        axes[10].grid(True, linestyle="--", alpha=0.3)
    else:
        axes[10].set_title("Latency distribution (no data)")
        axes[10].grid(True, linestyle="--", alpha=0.3)

    plot_worker_boxplots(axes[11], all_workers, all_lat)
    fig.tight_layout()

    if args.output:
        output_path = args.output
        output_path.parent.mkdir(parents=True, exist_ok=True)
        fig.savefig(output_path, dpi=150)
        print(f"Saved plots to {output_path}")
    else:
        plt.show()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
